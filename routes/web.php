<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthWebController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Broadcast;
use App\Filament\Resources\TournamentResource;
use App\Models\Tournament;

use App\Http\Controllers\Auth\SocialLoginController;

Route::middleware('web')->group(function () {
	Route::get('/', [AuthWebController::class, 'showLogin'])->name('login');
	Route::get('/login', [AuthWebController::class, 'showLogin']);
	Route::post('/login', [AuthWebController::class, 'login']);
	Route::post('/logout', [AuthWebController::class, 'logout']);
	Route::get('/invitation/{token}', [App\Http\Controllers\InvitationController::class, 'show'])->name('invitation.show');

	// Social Authentication Routes
	Route::get('auth/{provider}/redirect', [SocialLoginController::class, 'redirectToProvider'])->name('social.redirect');
	Route::get('auth/{provider}/callback', [SocialLoginController::class, 'handleProviderCallback'])->name('social.callback');
});

Route::get('/dashboard', [AuthWebController::class, 'dashboard'])->middleware('auth');


// Minimal email verification route that works without an active session.
// The link generated by the VerifyEmail notification is signed and contains an expiry.
// We validate the signature, ensure the id/hash match the user's email, mark verified
// and then redirect the user to the frontend where they can continue (login/register).
Route::get('/email/verify/{id}/{hash}', function (Request $request, $id, $hash) {
	// Validate the signed URL (expiration and signature)
	if (!$request->hasValidSignature()) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=invalid_signature');
	}

	$user = \App\Models\User::find($id);
	if (!$user) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=user_not_found');
	}

	// The verification hash should match the sha1 of the user's email (default Laravel)
	if (!hash_equals((string) $hash, sha1($user->getEmailForVerification()))) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=invalid_hash');
	}

	// Generate a temporary token stored in cache that the frontend can exchange to trigger verification.
	$token = \Illuminate\Support\Str::random(48);
	$cacheKey = 'email_verification_token:' . $token;
	// Store id and hash so the consumer API can validate and mark verified.
	\Illuminate\Support\Facades\Cache::put($cacheKey, ['id' => $id, 'hash' => $hash], now()->addMinutes(15));

	// If there's an outstanding invitation for this email, generate a frontend invite token
	// so the frontend can accept the invite after verification in a single flow.
	$ftoken = null;
	try {
		$inv = \Illuminate\Support\Facades\DB::table('institution_user')
			->where('invited_email', $user->email)
			->where('invitation_status', 'invited')
			->where('invitation_expires_at', '>', now())
			->first();
		if ($inv) {
			$ftoken = \Illuminate\Support\Str::random(48);
			$cacheKey2 = 'invite_frontend_token:' . $ftoken;
			\Illuminate\Support\Facades\Cache::put($cacheKey2, ['invitation_token' => $inv->invitation_token, 'institution_id' => $inv->institution_id], now()->addMinutes(60));
		}
	} catch (\Throwable $_) {
		// ignore
	}

	$frontend = env('FRONTEND_URL', config('app.url'));
	$url = $frontend . '/email-verified?token=' . $token . '&email=' . urlencode($user->email);
	if ($ftoken)
		$url .= '&ftoken=' . $ftoken . '&invite=' . urlencode($inv->invitation_token);
	return redirect($url);
})->middleware('signed')->name('verification.verify');

// Admin leaderboard shortcut that redirects into the Filament resource page.
Route::get('/admin/tournaments/{tournament}/leaderboard', function (Tournament $tournament) {
	return redirect(TournamentResource::getUrl('leaderboard', ['record' => $tournament]));
})->name('admin.tournaments.leaderboard');
