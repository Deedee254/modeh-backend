<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthWebController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Broadcast;
use App\Filament\Resources\TournamentResource;
use App\Models\Tournament;

Route::middleware('web')->group(function () {
	Route::get('/', [AuthWebController::class, 'showLogin'])->name('login');
	Route::get('/login', [AuthWebController::class, 'showLogin']);
	Route::post('/login', [AuthWebController::class, 'login']);
	Route::post('/logout', [AuthWebController::class, 'logout']);
	Route::get('/invitation/{token}', [App\Http\Controllers\InvitationController::class, 'show'])->name('invitation.show');

	// Social Authentication Routes (moved from api.php to avoid API middleware interference)
	Route::prefix('api')->group(function () {
		Route::get('auth/{provider}/redirect', [App\Http\Controllers\Auth\SocialAuthController::class, 'redirect']);
		Route::get('auth/{provider}/callback', [App\Http\Controllers\Auth\SocialAuthController::class, 'callback']);
	});
});

Route::get('/dashboard', [AuthWebController::class, 'dashboard'])->middleware('auth');

// Broadcasting auth endpoint for tests that call /broadcasting/auth directly.
// Implement a lightweight auth checker that mirrors the callbacks registered in routes/channels.php.
Route::post('/broadcasting/auth', function (Request $request) {
	$channel = $request->input('channel_name');
	$user = $request->user();

	if (!$user) {
		return response()->json(['message' => 'Unauthenticated'], 403);
	}

	// Strip Private/Presence prefixes if present (e.g., 'private-user.1', 'presence-user.1')
	$channel = preg_replace('/^(private|presence)-/', '', $channel);

	if (str_starts_with($channel, 'user.')) {
		$parts = explode('.', $channel);
		$id = $parts[1] ?? null;
		if ((int) $user->id === (int) $id) {
			return response()->json([], 200);
		}
		return response()->json([], 403);
	}

	if (str_starts_with($channel, 'group.')) {
		$parts = explode('.', $channel);
		$groupId = $parts[1] ?? null;
		try {
			$isMember = \App\Models\Group::where('id', $groupId)->whereHas('members', function ($q) use ($user) {
				$q->where('users.id', $user->id);
			})->exists();
			return response()->json([], $isMember ? 200 : 403);
		} catch (\Throwable $e) {
			return response()->json([], 403);
		}
	}

	// Default deny
	return response()->json([], 403);
});

// Minimal email verification route that works without an active session.
// The link generated by the VerifyEmail notification is signed and contains an expiry.
// We validate the signature, ensure the id/hash match the user's email, mark verified
// and then redirect the user to the frontend where they can continue (login/register).
Route::get('/email/verify/{id}/{hash}', function (Request $request, $id, $hash) {
	// Validate the signed URL (expiration and signature)
	if (!$request->hasValidSignature()) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=invalid_signature');
	}

	$user = \App\Models\User::find($id);
	if (!$user) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=user_not_found');
	}

	// The verification hash should match the sha1 of the user's email (default Laravel)
	if (!hash_equals((string) $hash, sha1($user->getEmailForVerification()))) {
		$frontend = env('FRONTEND_URL', config('app.url'));
		return redirect($frontend . '/email-verified?status=invalid_hash');
	}

	// Generate a temporary token stored in cache that the frontend can exchange to trigger verification.
	$token = \Illuminate\Support\Str::random(48);
	$cacheKey = 'email_verification_token:' . $token;
	// Store id and hash so the consumer API can validate and mark verified.
	\Illuminate\Support\Facades\Cache::put($cacheKey, ['id' => $id, 'hash' => $hash], now()->addMinutes(15));

	// If there's an outstanding invitation for this email, generate a frontend invite token
	// so the frontend can accept the invite after verification in a single flow.
	$ftoken = null;
	try {
		$inv = \Illuminate\Support\Facades\DB::table('institution_user')
			->where('invited_email', $user->email)
			->where('invitation_status', 'invited')
			->where('invitation_expires_at', '>', now())
			->first();
		if ($inv) {
			$ftoken = \Illuminate\Support\Str::random(48);
			$cacheKey2 = 'invite_frontend_token:' . $ftoken;
			\Illuminate\Support\Facades\Cache::put($cacheKey2, ['invitation_token' => $inv->invitation_token, 'institution_id' => $inv->institution_id], now()->addMinutes(60));
		}
	} catch (\Throwable $_) {
		// ignore
	}

	$frontend = env('FRONTEND_URL', config('app.url'));
	$url = $frontend . '/email-verified?token=' . $token . '&email=' . urlencode($user->email);
	if ($ftoken)
		$url .= '&ftoken=' . $ftoken . '&invite=' . urlencode($inv->invitation_token);
	return redirect($url);
})->middleware('signed')->name('verification.verify');

// Admin leaderboard shortcut that redirects into the Filament resource page.
Route::get('/admin/tournaments/{tournament}/leaderboard', function (Tournament $tournament) {
	return redirect(TournamentResource::getUrl('leaderboard', ['record' => $tournament]));
})->name('admin.tournaments.leaderboard');
